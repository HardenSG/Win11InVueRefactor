# 系统重构计划

[英文](./README_en.md)

## resume

[原项目](https://github.com/HardenSG/Win11-in-Vue)为第四届字节跳动青训营前端进阶版项目，我小组历时3周完成这个零组件库的`Win11 In Vue`的开发，作为主力开发人员，我贡献了约 `3 / 5` 的commit。

偶然回省代码，觉得某些地方写的并不好，比如内容写的比较死；代码重复量高、复用性差；没有过多考虑性能等客观因素；注册注册方式死板丑陋....。

因而想要对此进行重构，吸取先前教训。

+ 代码会尽量以`OOP` + `FP`编程范式叙写逻辑。
+ 系统由单系统过渡到`monorepo`，模板依赖于我的`cli`搭建
+ 注重分包，删除无意义冗余文件分层
+ 注重通用性，减少重复代码的书写，可以实践`HOC` or `HOF`提高复用性
+ 编写过程中，思考数据流向，拒绝无意义重复数据输入，及时察觉错误数据传递，以数据流向作为组件乃至文件分包分层的导向依据

## stack

+ `Vite`
+ `Typescript`
+ `Vue3`
+ `Pinia`
+ `VueRouter`

## 架构演变方向

应用注册方式变为手动导出自动注册，通过`scheduler/apps`导出你所需要的 `packages/app`中的应用，第三方开发者只需要在其中编写应用即可。

理论上：第三方开发者完全可以采用`npm`第三方发包的方式进行应用的插装，你只需要在`scheduler/apps`中简单的`import`一下就可以使用，系统会提供一些数据，通过`provide`依赖注入形式，注入到第三方编写的组件中，更多组件编写规则，请参考`app`开发规范[组件编写规范](packages/app/README.md)

导出的组件会由统一调度器`Scheduler`进行管理，因此在Root(View/Home)组件的创建初期，对`Scheduler`进行初始化和挂载。通过调度器中的信息，而后对这些组件进行处理即可，最后处理的结果就是一个组件数组。因此，系统会直接遍历进行挂载即可

```javascript
{Object.keys(Applications).map((key, idx) => {
    var WinApp = Applications[key];
    return <WinApp key={idx} />;
})}
```

+ [x] 组件应该伪挂载，在不需要出现的时候不应该被渲染，否则毫无疑问这会拖垮首屏渲染，因此需要对未出现的组件统统remove，不渲染进`dom tree`

+ [x] 将所有的组件和`taskBar`做联动，当点击的时候控制对应的组件显现。通过`nomalize HOC`实现，也就是说所有的应用其实都是要通过`HOC`做处理的，这样这个组件就会被`HOC`所管理，每个组件都会开启一个新的`HOC`，因此他们之间互不干扰

### 重构`ToolsBar`

+ [x] 组件最小化不应该进行隐藏，而是隐藏层级，因为频繁的触发 `display：none` 会引起性能问题
+ [x] 组件关闭需要考虑是否进行`display：none`，因为关闭后可能短时间内不会再次打开
+ [x] 组件关闭最小化与否通过调用`scheduler`的方法实现
+ [ ] `TODO`：`ToolBar`作为公共组件，为了更好的维护性应实践`OOP`的开发方式，因此接下来的工作会着重于refactor ToolBar component and optimization it

### 如何做好全局联动？

> 单纯依靠对象的引用特性难以达成需求，如果依靠响应式那么如何将`scheduler`数据流向全局？

+ [ ] 如果采用`props`那就意味着需要对所有的组件进行改动，这显然违背开闭原则
+ [ ] 如果采用依赖注入的方式依然可以实现跨组件共享数据，同时可以确保所有组件都能够正常接收，因为他们同属于一个依赖链，但是性能负担较大，如果大规模组件存在，难以保证性能。
  + 这里的性能负担指的是，同一数据要被顶层`App`的自己组件也消费，这样注入的依赖深度就可能会不止3层（依赖注入3层以上的传递可能会造成严重的性能问题）
  + 因此不确定性就是不稳定的因素。但是如果要作为系统与应用间的数据共享，是一个很好的选择，因为这既打通了系统间的沟通壁垒，又能将数据流向控制在顶层依赖链中，但是这需要开发者自行遵守
+ [x] 采用`store`方式可以实现跨组件间共享数据
  + 注意这里说的跨组件应用传递指的是系统中，包括系统的内置`baseComponent`是根据状态管理工具进行数据共享的。
  + `TODO`：`App`级的应用，初步还是想依赖于依赖注入。

### 重构`taskBar`

+ 底部栏根据你的配置决定是否固定 通过 `Scheduler` - `IsFixTaskBar`实现
+ ~~底部栏要联动桌面 通过`HOC`实现~~
+ `taskBar`还需要考虑当前打开的`app`是否是`taskBar`固定的，如果是固定的就原地打开即可，如果不是就末位打开，按照时间戳排序（UI层消化）

+ [x] `ToolsBar`联动`pinia.components`实现层级切换，这就需要组件具备自治能力，因此在此采用`OOP`建立自定义组件类是最佳实践

`taskbar`同步消费`currentShowTaskbar`，数据按照时间戳进行排序
`desktop`要消费`scheduler.components`数据，可以直接消费`pinia`的`components`即可

**做到多向联动性是系统互联的基础**

---

## 继续演变

### 为什么要继续演变？

因为如果`TaskBar`继续采用`HOC`方案，那么目标应用在开启的时候需要打开两次，这不是一个好的结果

### 那么如何做到组件统一管理，且只渲染一次呢？

我的思路是仍然保留`scheduler`方案，`HOC`方案也可以继续得以保留，因为以`HOC`方案做组件的管理要更加单一化细粒度，各`HOC`各司其职

那么就需要`taskBar`做出让步，因此`taskBar`的渲染方案并不是继续采用`HOC`方案，而是自己渲染出一套`icon`来

通过各组件自行管理的方式导出`CustomComponent`类实例，其内置组件信息，`taskBar`可基于此对其进行渲染

### 如何在组件隐藏的时候能同步`taskbar`样式

想起来很简单，因为如果是正在显示的话，一定是存在于`currentShowComponent`中的，如此一来，我需要在`taskBar`中做出操作

#### 如何操作？

要分为不同的考虑方式
> `taskBar`的显示数据源分为两个部分：`fixTaskBarComponent`和`currentShowComponent`
> 因此需要考虑：

1. 如果是`fixTaskBarComponent`的任务显示无论`order`与否都是原地显示的
2. 如果不是`fixTaskBarComponent`中的任务显示就需要根据`order`进行排序，`order`越小距离左侧越近（这个地方写死还是做动态化需要考虑）

因此渲染还需要依赖于`currentShowComponent`，对于隐藏（非关闭）的组件来讲，它仍然还存在于`currentShowComponent`中，因此这个时候需要根据`isHide`判断（需要分区域考虑了）是否隐藏，对当前显示的和隐藏的内容所应用的类是不同的比如显示的是长蓝色条，隐藏的是白色的条

因此在`components/taskbar.vue`的`computed`阶段就需要进行划分了，将不是`fixTaskBarComponent`的任务划分出来，这部分是需要用`order`排序的（这个保留与否有待思考，因为感觉不太美观）

只要不是`fixTaskBarComponent`的内容就直接根据`isHide`处理就好了

待续....
